package hw06pipelineexecution

// Алиасы на типы каналов для ясности при использовании в пайплайне.
type (
	In  = <-chan interface{}
	Out = In
	Bi  = chan interface{}
)

// Stage представляет собой функцию-стейдж для пайплайна.
type Stage func(in In) (out Out)

// ExecutePipeline запускает конкуррентный пайплайн, состоящий из стейджей.
func ExecutePipeline(in In, done In, stages ...Stage) Out {
	lout := in

	// Запуск каждого стейджа в пайплайне
	for _, stage := range stages {
		// ротируется канал с данными, от поступивших входных данных в in до последнего выполненного стейджа
		lout = runStage(lout, done, stage)
	}

	// после запуска всех горутин с последовательной передачей канала с данными по всему пайплайну в стейджи
	// происходит возврат последнего канала с результирующими данными
	// при этом если обработка прерывается по каналу done, то результирующая обработка данных очевидно непредсказуема
	return lout
}

// runStage обрабатывает выполнение отдельного стейджа в горутине.
func runStage(in In, done In, stage Stage) Out {
	lbiout := make(Bi) // локальный двунаправленный канал для записи результатов
	// и их возврата в этом же канале виде однонаправленнго канала на чтение

	// Запуск анонимной горутины для фоновой обработки стейдж-функции, фоновая в том смысле что... (см. ниже)
	go func() {
		defer close(lbiout)
		// бесконечный цикл обработки данных из входного канала
		for {
			// не забываем отслеживать закрытие канала done
			select {
			case <-done:
				return
			// выгребаем данные из входного канала
			case data, ok := <-in:
				if !ok {
					// если канал закрыт (!ok), горутина завершается.
					return
				}

				// Вызов обертки для стейджа с данными из входного канала
				result := stageWrapper(stage, data)

				// если канал done все ещё не закрыт или что то же самое всё ещё открыт,
				// т.е. всё ещё не было сигнала на завершение,
				// то передается результат выполнения стейджа над данными в выходной канал
				select {
				case <-done:
					return
				case lbiout <- result:
				}
			}
		}
	}()

	// ...пока та горутина запускается и работает, канал уже возвращается (возможно даже ещё без данных).
	return lbiout
}

// stageWrapper создает обертку для стейджа, производя прием и возврат данных через каналы.
func stageWrapper(stage Stage, data interface{}) interface{} {
	lbiout := make(Bi)   // локальный двунаправленный канал для передачи результирующих выходных данных стейджа
	lbiin := make(Bi, 1) // локальный буферизованный двунаправленный канал с буфером (что бы избежать блокировки),
	// использующийся для передачи входных данных стейджу

	// Так как канал имеет буфер, отправка не блокирует выполнение горутины до момента, когда данные будут получены.
	lbiin <- data

	// Запускается анонимная горутина для выполнения стейджа в фоновом режиме.
	go func() {
		defer close(lbiout)
		close(lbiin)

		// Выполнение стейджа с входным каналом
		stageOut := stage(lbiin)

		// Передача данных из выходного канала стейджа в выходной канал
		for data := range stageOut {
			lbiout <- data
		}
	}()

	// Возврат результата из оберточного канала,
	// пока та горутина запускается и работает, канал уже возвращается (возможно даже ещё без данных).
	return <-lbiout
}
